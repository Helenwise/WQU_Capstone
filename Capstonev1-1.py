#! /usr/bin/env py36
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 25 21:48:04 2018

@author: justinluiks
"""
#Python 3.6.2 |Anaconda custom (64-bit)|

import pandas as pd #version 0.22.0
import matplotlib.pyplot as plt #version 2.0.2
import xgboost as xgb #version 0.60
from sklearn.metrics import accuracy_score #version 0.19.0
from alpha_vantage.timeseries import TimeSeries #version 1.2.0
from xgboost import XGBClassifier #version 0.60
from sklearn.linear_model import Lasso
from sklearn.linear_model import Ridge

#The target variables will be transformed for binary classification.  
#A positive change in the value of prices will be classified as 1 
#and a non-positive change as 0.
def getBinary(val):
    if val>0:
        return 1
    else:
        return 0

ts = TimeSeries(key='5Z6EQ1UKJF52IT5Y',output_format='pandas')

#uncomment the below statement to download the data from 
#https://www.alphavantage.co/"
#SPY, meta_data = ts.get_daily('SPY',outputsize='full')
#SPY.to_csv('SPY.csv')
SPY1 = pd.read_csv('SPY.csv')
SPY1.rename(columns={'Unnamed: 0':'Date'},inplace=True)
SPY1.set_index('Date', inplace=True)

'''

We are going to omit High, Low and Close, using only Open and Volume for the study.  
Let’s start preparing the data for the analysis.  
The predictors (X variables) to be used to predict the target magnitude (y variable) 
will be the following ones:
    
    •	Two day simple moving average (SMA2).  
    The formula is (Ct-Ct-1)/2, being Ct equal to current day’s open price and 
    Ct-1 to previous day’s open price.  This formula is applied to each row of the data set.

    •	One day window SMA2.  
    One day window SMA2.  The previous day’s SMA2 value.
    
    And the other predictors are as follows:
    •	Current days SMA2 increment. (SMA2t – SMA2t-1)
    •	One day windows SMA2 increment. (SMA2t-1 - SMA2t-2)
    •	Current day volume increment. (Volt – Volt-1)
    •	Current day volume rate of change. (Volt – Volt-1)/Volt
    •	One day window open price. (Ct – 1)
    •	Current day open price increment. (Ct – Ct-1)
    •	Current day open price. Ct
'''

Predictors = pd.DataFrame({"sma2":SPY1.open.rolling(window=2).mean()})
Predictors["sma2_1"] = Predictors.sma2.shift(1)
Predictors["sma2_increment"] = Predictors.sma2.diff()  
Predictors["sma2_1_increment"] = Predictors.sma2_1.diff()  
Predictors["vol_increment"] = SPY1.volume.diff()
Predictors["vol_rel_increment"] = SPY1.volume.diff() / SPY1.volume
Predictors["open_1"] = SPY1.open.shift(1)
Predictors["open_incr"] = SPY1.open - SPY1.open.shift(1)
Predictors["open"] = SPY1.open
 
# The rows with nulls generated by rolling values will be removed.
Predictors = Predictors.dropna()

#This will be a classification variable, 
#if the average price will go either up or down the next day.  
#The target will be forecasting the difference between today’s price and 
#tomorrow’s price (which is unknown).

target = pd.DataFrame({"value":Predictors.sma2.shift(-1) - Predictors.sma2}).dropna()

#Finally, we will match predictors and target values by date and 
#remove those rows without counterpart in the other table.

X = pd.merge(Predictors, target,left_index=True,right_index=True)[Predictors.columns]
y = pd.merge(Predictors, target,left_index=True,right_index=True)[target.columns]

'''
We will setup the regression model using the 65% of the data and with that model, 
the next 35% of the data will be used to predict future values.  
This simulates the actual scenario in which we have past data to train or model and 
we want to predict how a future data will be with the data we currently have on hand.  
The data will be split in two sets: the training set to preconfigure the model and 
the testing set that won’t be used to build the model, but only to test 
if it works as expected with new data.  
'''

train_samples = int(X.shape[0] * 0.65)
 
X_train = X.iloc[:train_samples]
X_test = X.iloc[train_samples:]
 
y_train = y.iloc[:train_samples]
y_test = y.iloc[train_samples:]

#The model is trained and the test data predicted to verify the accuracy of the system.  
y_test_binary = pd.DataFrame(y_test['value'].apply(getBinary))
print()

#########
#XGBoost#
#########
print('####################')
print('#XGBOOST Regression#')
print('####################')

regressor = xgb.XGBRegressor(gamma=0.0,n_estimators=150,base_score=0.7,colsample_bytree=1,learning_rate=0.01)
 
xgbModel = regressor.fit(X_train,y_train.value.apply(getBinary))
 
y_predicted = xgbModel.predict(X_test)
y_predicted_binary = [1 if yp >=0.5 else 0 for yp in y_predicted]
 
print('The accuracy score of XGBoost Regression is: {:.3f}'.format(accuracy_score(y_test_binary,y_predicted_binary)))
print()

model = XGBClassifier(n_estimators=500)
model.fit(X_train,y_train.value.apply(getBinary))

#The features used should also be analyzed to avoid using redundant variables 
#and to discard those with no correlation.  
#New features should be added to try improved approaches. 

feature_importance = model.feature_importances_

fig = plt.figure(figsize=(8,8))
plt.title('XGBOOST feature importance chart')
plt.xticks(rotation='vertical')
plt.bar([i for i in range(len(feature_importance))], feature_importance.tolist(), tick_label=X_test.columns, color="chocolate")
plt.show()
print()

#######
#Ridge#
#######
print('##################')
print('#RIDGE Regression#')
print('##################')
ridge = Ridge().fit(X_train, y_train)

y_predicted_ridge = ridge.predict(X_test)
y_predicted_binary_ridge = [1 if yp >=0.5 else 0 for yp in y_predicted_ridge]
print('The accuracy score of Ridge Regression is: {:.3f}'.format(accuracy_score(y_test_binary,y_predicted_binary_ridge)))
print()

#######
#Lasso#
#######
print('##################')
print('#LASSO Regression#')
print('##################')
lasso = Lasso().fit(X_train,y_train.value.apply(getBinary))

y_predicted_lasso = lasso.predict(X_test)
y_predicted_binary_lasso = [1 if yp >=0.5 else 0 for yp in y_predicted_lasso]
print('The accuracy score of Lasso Regression is: {:.3f}'.format(accuracy_score(y_test_binary,y_predicted_binary_lasso)))
